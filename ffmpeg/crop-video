#!/usr/bin/env zx
"use strict"

import "zx/globals"
import Help from "../api/help.mjs"
import Ffmpeg from "../api/ffmpeg.mjs"

const exit = process.exit

const argv = minimist(process.argv.slice(3), {
    string: ["ratio"],
    alias: { help: ["h"], preview: ["p"] },
    boolean: ["help", "preview", "debug"],
})

if (argv.help) {
    const helper = new Help("Usage: crop-video [OPTIONS] INPUT [OUTPUT]")
    helper.argument("INPUT", "Path to input video").argument("OUTPUT", "Path to output video. (optional)")
    helper
        .option(
            "--ratio ASPECT_RATIO",
            "Use a ratio instead of auto detect to crop. (ex: --ratio 1/2, --ratio 18*9, --ratio 16:9)"
        )
        .option("--auto", "Auto detect black bar to crop. Enable by default but disabled when --ratio is passed.")
        .option("--white", "Auto detect white bar instead of black to crop")
        .option("--top PIXEL", "Number of pixel to add to the top after calculating the crop")
        .option("--bottom PIXEL", "Number of pixel to add to the bottom after calculating the crop")
        .option("--right PIXEL", "Number of pixel to add to the right after calculating the crop")
        .option("--left PIXEL", "Number of pixel to add to the left after calculating the crop")
        .option("--around PIXEL", "Number of pixel to add to the around after calculating the crop")
        .option("--threads NUMBER", "Number of threads to use when transcoding. Default is 4")
        .option("--preview", "Show a preview of the crop instead of outputting it")
        .option("-h, --help", "Prints the help menu")
        .option("--debug", "Prints the debug info")

    echo($({ input: helper.toString(), sync: true })`cm`)
    exit(0)
}

if (argv.debug) console.log(argv)

/** @type {string} */
const videoPath = argv.i ?? argv._?.[0]
const videoExists = (await $`[[ -f ${videoPath} ]]`.exitCode) === 0

if (!videoPath) {
    console.log(chalk.red("Please provide a path to a video"))
    exit(1)
} else if (!videoExists) {
    console.log(chalk.red("Provided path doesn't exists"))
    exit(1)
}

console.log(`Input video path: ${chalk.cyan(videoPath)}`)

const ffprobeProcess = $`ffprobe -v error -select_streams v:0 -show_entries format=duration -show_entries stream=width,height -of json ${videoPath}`
const ffprobeInfo = await spinner("Retrieving height and width", () => ffprobeProcess)

const ffprobeJson = JSON.parse(ffprobeInfo.stdout)

if (!ffprobeJson.streams.length) {
    console.log(chalk.red("Failed to find any video stream on input path"))
    exit(1)
}

/** @type {number} */
const videoWidth = ffprobeJson.streams[0].width
/** @type {number} */
const videoHeight = ffprobeJson.streams[0].height

class Crop {
    /**
     * @param w {number}
     * @param h {number}
     * @param x {number}
     * @param y {number}
     */
    constructor(w, h, x, y) {
        this.w = parseInt(w)
        this.h = parseInt(h)
        this.x = parseInt(x)
        this.y = parseInt(y)
    }

    /** @param amount {number} */
    left(amount) {
        amount = this.x - amount < 0 ? this.x : amount
        this.x -= amount
        this.w += amount
    }

    /** @param amount {number} */
    right(amount) {
        amount = this.w + amount > videoWidth - this.x ? videoWidth - this.x : amount
        this.w += amount
    }

    /** @param amount {number} */
    top(amount) {
        amount = this.y - amount < 0 ? this.y : amount
        this.y -= amount
        this.h += amount
    }

    /** @param amount {number} */
    bottom(amount) {
        amount = this.h + amount > videoHeight - this.y ? videoHeight - this.y : amount
        this.h += amount
    }

    toString() {
        const { w, h, x, y } = this
        return `crop=${w}:${h}:${x}:${y}`
    }
}

/** @type {Crop} */
let crop

if (argv.ratio) {
    const [cropWidth, cropHeight] = argv.ratio.split(/\/|x|:/).map(parseFloat)

    const rw = videoWidth / cropWidth
    const rh = videoHeight / cropHeight
    const ratio = Math.min(rw, rh)

    const newWidth = Math.round(ratio * cropWidth)
    const newHeight = Math.round(ratio * cropHeight)

    const x = Math.round((videoWidth - newWidth) / 2)
    const y = Math.round((videoHeight - newHeight) / 2)

    crop = new Crop(newWidth, newHeight, x, y)
} else {
    const detectionTime = argv.dt || 2
    const filter = `eq=contrast=1.8,${argv.white ? "negate," : ""}cropdetect`

    const command = $`ffmpeg -i ${videoPath} -t ${detectionTime} -vf ${filter} -f null - 2>&1 | tail | awk '/crop/ { print $NF }'`

    const detection = await spinner("Deteccting crop from video using ffmpeg...", () => command)
    const detectedCrop = detection.lines().at(1).slice(5).split(":")

    crop = new Crop(...detectedCrop)
}

if (typeof argv.top === "number") crop.top(argv.top)
if (typeof argv.bottom === "number") crop.bottom(argv.bottom)
if (typeof argv.right === "number") crop.right(argv.right)
if (typeof argv.left === "number") crop.left(argv.left)
if (typeof argv.around === "number") {
    crop.top(argv.around)
    crop.bottom(argv.around)
    crop.right(argv.around)
    crop.left(argv.around)
}

let outputPath = argv.o ?? argv._?.[1]
if (!outputPath) {
    const inputPathSplit = videoPath.split(".")
    inputPathSplit.splice(inputPathSplit.length - 1, 0, `${crop.w}x${crop.h}`)
    outputPath = inputPathSplit.join(".")
}

if (argv.preview) {
    const previewRatio = Math.max(crop.w, crop.h) / 500
    const filter = `${crop},scale=${Math.round(crop.w / previewRatio)}:${Math.round(crop.h / previewRatio)}`
    await $`ffplay -i ${videoPath} -hide_banner -vf ${filter}`.quiet(true)
} else {
    if (argv.debug) console.log(crop)

    const ffmpegProgress = $`ffmpeg -i ${videoPath} -threads ${argv.threads ?? 4} -vf ${crop} ${outputPath} 2>&1`
    await new Ffmpeg().progress(ffmpegProgress, [])
}
