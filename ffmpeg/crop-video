#!/usr/bin/env zx
"use strict"

import cliProgress from "cli-progress"
import inquirer from "inquirer"
import "zx/globals"
import Help from "../api/help.mjs"

const exit = process.exit

const argv = minimist(process.argv.slice(3), {
    string: ["ratio"],
    alias: { help: ["h"], preview: ["p"] },
    boolean: ["help", "preview", "debug"],
})

if (argv.help) {
    const helper = new Help("Usage: crop-video [OPTIONS] INPUT [OUTPUT]")
    helper.argument("INPUT", "Path to input video").argument("OUTPUT", "Path to output video. (optional)")
    helper
        .option(
            "--ratio ASPECT_RATIO",
            "Use a ratio instead of auto detect to crop. (ex: --ratio 1/2, --ratio 18*9, --ratio 16:9)"
        )
        .option("--auto", "Auto detect black bar to crop. Enable by default but disabled when --ratio is passed.")
        .option("--white", "Auto detect white bar instead of black to crop")
        .option("--top PIXEL", "Number of pixel to add to the top after calculating the crop")
        .option("--bottom PIXEL", "Number of pixel to add to the bottom after calculating the crop")
        .option("--right PIXEL", "Number of pixel to add to the right after calculating the crop")
        .option("--left PIXEL", "Number of pixel to add to the left after calculating the crop")
        .option("--around PIXEL", "Number of pixel to add to the around after calculating the crop")
        .option("--threads NUMBER", "Number of threads to use when transcoding. Default is 4")
        .option("--preview", "Show a preview of the crop instead of outputting it")
        .option("-h, --help", "Prints the help menu")
        .option("--debug", "Prints the debug info")

    echo($({ input: helper.toString(), sync: true })`cm`)
    exit(0)
}

if (argv.debug) console.log(argv)

/** @type {string} */
const videoPath = argv.i ?? argv._?.[0]
const videoExists = (await $`[[ -f ${videoPath} ]]`.exitCode) === 0

if (!videoPath) {
    console.log(chalk.red("Please provide a path to a video"))
    exit(1)
} else if (!videoExists) {
    console.log(chalk.red("Provided path doesn't exists"))
    exit(1)
}

log(`Input video path: ${chalk.cyan(videoPath)}`)

const ffprobeInfo = await spinner(
    "Retrieving height, width and total frame",
    () =>
        $`ffprobe -v error -select_streams v:0 -show_entries format=duration -show_entries stream=width,height,r_frame_rate -of json ${videoPath}`
)

const ffprobeJson = JSON.parse(ffprobeInfo.stdout)

if (!ffprobeJson.streams.length) {
    console.log(chalk.red("Failed to find any video stream on input path"))
    exit(1)
}

/** @type {number} */
const fps = eval(ffprobeJson.streams[0].r_frame_rate)
const duration = parseFloat(ffprobeJson.format.duration)
const totalFrames = Math.round(duration * fps)
/** @type {number} */
const videoWidth = ffprobeJson.streams[0].width
/** @type {number} */
const videoHeight = ffprobeJson.streams[0].height

class Crop {
    /**
     * @param w {number}
     * @param h {number}
     * @param x {number}
     * @param y {number}
     */
    constructor(w, h, x, y) {
        this.w = parseInt(w)
        this.h = parseInt(h)
        this.x = parseInt(x)
        this.y = parseInt(y)
    }

    /** @param amount {number} */
    left(amount) {
        amount = this.x - amount < 0 ? this.x : amount
        this.x -= amount
        this.w += amount
    }

    /** @param amount {number} */
    right(amount) {
        amount = this.w + amount > videoWidth - this.x ? videoWidth - this.x : amount
        this.w += amount
    }

    /** @param amount {number} */
    top(amount) {
        amount = this.y - amount < 0 ? this.y : amount
        this.y -= amount
        this.h += amount
    }

    /** @param amount {number} */
    bottom(amount) {
        amount = this.h + amount > videoHeight - this.y ? videoHeight - this.y : amount
        this.h += amount
    }

    toString() {
        const { w, h, x, y } = this
        return `crop=${w}:${h}:${x}:${y}`
    }
}

/** @type {Crop} */
let crop

if (argv.ratio) {
    const [cropWidth, cropHeight] = argv.ratio.split(/\/|x|:/).map(parseFloat)

    const rw = videoWidth / cropWidth
    const rh = videoHeight / cropHeight
    const ratio = Math.min(rw, rh)

    const newWidth = Math.round(ratio * cropWidth)
    const newHeight = Math.round(ratio * cropHeight)

    const x = Math.round((videoWidth - newWidth) / 2)
    const y = Math.round((videoHeight - newHeight) / 2)

    crop = new Crop(newWidth, newHeight, x, y)
} else {
    const detectionTime = argv.dt || 2
    const filter = `eq=contrast=1.8,${argv.white ? "negate," : ""}cropdetect`

    const command = $`ffmpeg -i ${videoPath} -t ${detectionTime} -vf ${filter} -f null - 2>&1 | tail | awk '/crop/ { print $NF }'`

    const detection = await spinner("Deteccting crop from video using ffmpeg...", () => command)
    const detectedCrop = detection.lines().at(1).slice(5).split(":")

    crop = new Crop(...detectedCrop)
}

if (typeof argv.top === "number") crop.top(argv.top)
if (typeof argv.bottom === "number") crop.bottom(argv.bottom)
if (typeof argv.right === "number") crop.right(argv.right)
if (typeof argv.left === "number") crop.left(argv.left)
if (typeof argv.around === "number") {
    crop.top(argv.around)
    crop.bottom(argv.around)
    crop.right(argv.around)
    crop.left(argv.around)
}

let outputPath = argv.o ?? argv._?.[1]
if (!outputPath) {
    const inputPathSplit = videoPath.split(".")
    inputPathSplit.splice(inputPathSplit.length - 1, 0, `${crop.w}x${crop.h}`)
    outputPath = inputPathSplit.join(".")
}

function formatTime(sec_num) {
    if (sec_num === Infinity) return "N/A"
    let hours = Math.floor(sec_num / 3600)
    let minutes = Math.floor((sec_num - hours * 3600) / 60)
    let seconds = sec_num - hours * 3600 - minutes * 60

    if (hours < 10) hours = "0" + hours
    if (minutes < 10) minutes = "0" + minutes
    if (seconds < 10) seconds = "0" + seconds.toFixed(2)

    return `${hours}:${minutes}:${typeof seconds === "string" ? seconds : seconds.toFixed(2)}`
}

if (argv.preview) {
    const previewRatio = Math.max(crop.w, crop.h) / 500
    const filter = `${crop},scale=${Math.round(crop.w / previewRatio)}:${Math.round(crop.h / previewRatio)}`
    await $`ffplay -i ${videoPath} -hide_banner -vf ${filter}`.quiet(true)
} else {
    if (argv.debug) console.log(crop)

    if ((await $`[[ -d ${outputPath} ]]`.exitCode) !== 0) {
        const response = await inquirer.prompt([
            {
                name: "answer",
                type: "confirm",
                message: `File ${outputPath} already exists. Overright it? `,
            },
        ])
        if (!response.answer) exit(0)
    }

    const ffmpegProcess = $`ffmpeg -i ${videoPath} -hide_banner -threads ${argv.threads ?? 4} -y -vf ${crop} ${outputPath} -f null - 2>&1`

    const percentage = "{percentage}%"
    const frames = "{value}/{total} Frames"
    const fps = "fps: {fps}"
    const eta = "ETA: {remaining}"
    const bar = new cliProgress.SingleBar({
        format: `ffmpeg : ${chalk.green("{bar}")} | ${percentage} || ${frames} || ${fps} || ${eta}`,
        barCompleteChar: "\u2588",
        barIncompleteChar: "\u2591",
        hideCursor: true,
    })

    let started = false
    for await (const chunk of ffmpegProcess.stdout) {
        /** @type {string} */
        const data = chunk.toString()
        const regex = /frame= *(\d+) *fps= *(\d+)/i
        const ffmpegProgress = data.match(regex)
        if (!ffmpegProgress) continue
        const frames = parseInt(ffmpegProgress[1])
        const fps = parseInt(ffmpegProgress[2])
        const remaining = formatTime((totalFrames - frames) / fps)

        if (!started) {
            bar.start(totalFrames, frames, { fps, remaining })
            started = true
        }

        bar.update(frames, { fps, remaining })
    }
    bar.update(totalFrames)
    bar.stop()
}
